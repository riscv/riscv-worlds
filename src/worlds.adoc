:le: &#8804;
:ge: &#8805;
:imagesdir: ./images

[[worlds]]

== RISC-V Worlds

The _RISC-V Worlds_ provides isolation in a hardware platform by
constraining access to system physical addresses.  It provides
_Worlds_ , which are execution contexts that include agents (such as
harts and devices) that can initiate a transaction on a physical
address within a world, and resources (such as memories and peripheral
devices) that respond to transactions at a physical address within a
world.  Worlds are created and configured by a trusted execution
environment, usually at system boot time.

Worlds are uniquely identified by a hardware _World_ _Identifier_
(_WID_) and the maximum number of unique WIDs on a platform is
_NWorlds_.  Increasing NWorlds increases the hardware cost, and in
practice, 2-8 WIDs (requiring 1-3 bits to represent) are sufficient
for many use cases.

Hardware agents (harts and devices) that can initiate transactions on
physical addresses may support multiple contexts, with each context
potentially being in a different world.  A software context running on
a hart agent is present in one world at a time.  A hardware context on
a device agent is present in one world at a time.

Resources are identified by system physical addresses.  A world may be
granted read, write, or both, access permissions on a physical
address.  A resource can optionally be shared between worlds, with
independent access permissions for each world.

The _RISC-V Worlds_ is designed for the case where the allocation of
agent contexts and resources to worlds is performed before or at
reset/boot time, and not changed dynamically when the system is running
unless there is a system reset.  Efficiently changing worlds allocation
configurations dynamically while the system is running is not a goal of
the current specification.

When an agent context initiates a transaction to a physical address,
hardware tags the transaction with the WID of the agent context.  The
transaction is only allowed to complete successfully if the targeted
resource has the appropriate access permissions (read or write)
on that address for the WID on the transaction.  The permission checks
might be performed at the agent, at the resource, or anywhere along the
path the transaction takes through the platformâ€™s bus hierarchy.  The bus
transaction carries the WID through the interconnect and all elements
on the path toward the targeted resource until access permissions can
be checked.  The method of propagating and checking the WID on busses
is platform-specific, with different bus fabrics supporting WIDs in
bus-specific ways. Similarly, any cache on the path that may need to
allocate data into cache lines must consider the WID of the original
transaction. The method of propagating and using the WID through caches is
platform-specific, as well as the cache policy.

NOTE: Theoretically all permissions checks on transactions could be
performed at the source agent to prevent any illegal transactions from
entering the bus fabric. But in practice, replicating and checking the
entire platform permissions map at each agent is prohibitively
expensive, particularly when permissions are configurable, and so it is
assumed that permissions checking is distributed out in the bus fabric and
attached resources.

If the permission check fails, the transaction is terminated or
modified to avoid violating world isolation and the failure may be
reported. Failures may be reported in a number of ways depending on
the platform, the agent, the resource, and the transaction type.
Failures may be reported to the initiating agent, and optionally one
or more other agents. In some cases, the failure cannot be directly
reported to the initiating agent and the transaction is modified to be
ignored or to return benign data.  In these cases, the failure may
still be reported to a different agent through an alternate mechanism.

=== RISC-V ISA World-ID Extensions

RISC-V harts that support Worlds associate a WID with all memory
accesses initiated by that hart.  The World-ID extensions allow
different privilege modes on a hart to be tagged with different WIDs.

There are the following levels of Worlds support on RISC-V harts.

* Without any Worlds ISA extensions enabled, a Worlds-capable implementation
  will fix the WID to a platform-defined value for the outgoing transactions of
  all privilege modes on a hart. This platform-defined value is referred to as
  `pmwid`.
* With the *Smwid* extension, the `mwid` CSR is introduced to provide a
  lockable control of the WID value assigned to the hart. A platform-defined
  value, `pmwidlist`, may limit the set of WIDs that can be used with `mwid`.
* The *Smlwid* extension introduces the `mlwid` CSR to control the WID of
  lower-privilege modes. A platform-defined value, `pmlwidlist`, may limit the
  set of WIDs that can be used with `mlwid`.
* The *Smlwidlist* extension depends on the *Smwid* and *Smlwid* extensions, it
  introduces the `mlwidlist` CSR to allow M-mode to restrict the set of WIDs
  that may be used with `mlwid`. The `mlwidlist` CSR is locked (read-only)
  whenever `mwid` is locked.
* Next comes the *Smwdeleg* extension, which further enable
  M-mode to delegate to S-mode the ability to assign the WID of S-mode lower-
  privilege modes (i.e., U-mode), thereby adding the *Sswid* extension to S-mode
  with the `slwid` CSR.

All accesses, including implicit memory references such as instruction
fetches and page-table walks, must be tagged with the appropriate WID.

*World-ID extensions do not allow a privilege mode to change its own WID.* The
only exception to this rule is the `mwid` CSR that, if unlocked on-reset,
allows M-mode to set and lock the WID that applies to itself. This is
thematically consistent with lockable registers in other extensions (e.g. PMP),
where early-boot M-mode may be operating as a root-of-trust, with a temporal
boundary to separate it from the subsequent "run-time" M-mode firmware. In this
way, early-boot M-mode firmware (that is, code executing before the
M-mode-constraining registers are locked) is considered to be more privileged
than regular M-mode (after the constraints are locked), and in this way it
still respects the spirit of the aforementioned rule.

The only extension that is dependent on *Smwid* is *Smlwidlist*, the other
Worlds extensions have no dependence on *Smwid*.  If the *Smwid* extension is
not enabled, the `mwid` CSR does not exist.  If *Smwid* is enabled, the
platform determines whether `mwid` is locked or unlocked on-reset.

NOTE: It is platform-specific whether or not `mwid` changes between resets.

NOTE: Different harts in a system may have different WIDs in M-mode.

=== RISC-V Worlds CSRs

The RISC-V Worlds Smlwid, Smwdeleg, and Sswid extensions allow a hart to
assign WIDs to its privilege modes and masks to control the values that
are authorized for use with the principle that no privilege mode can change
its own WID.  The CSRs for these extensions are listed in the Table below.

[cols="1,1,^1,^1,5"]
.World-ID CSRs
|===
|Size in bits|Register|Access|Proposed CSR Address|Description
| `XLEN` | `mlwid` | WARL for M | `0x390` | WID used for lower privilege modes.
`Ceil(Log~2~NWorlds)` LSBs are used, others are zero.
| `XLEN` | `mwiddeleg` | WARL for M | `0x748` | Set of WID
values delegated to S-mode, represented as a bit vector. `NWorlds` LSBs
are used, others are zero.
| `XLEN` | `slwid` | WARL for S | `0x190` | WID value used in lower modes
(i.e., U-mode). `Ceil(Log~2~NWorlds)` LSBs are used, others are zero.
|===

The RISC-V Worlds adds additional extensions Smwid and Smlwidlist to allow a
hart to observe and modify the WID assigned to M-mode as well as the set of
WIDs that are delegated to lower privilege modes.

[cols="1,1,^1,^1,5"]
.Optional World-ID CSRs
|===
|Size in bits|Register|Access|Proposed CSR Address|Description
| `XLEN` | `mwid` | WARL for M | ??? | WID used for M-mode with the optional
Smwid extension.  `Ceil(Log~2~NWorlds)` LSBs are used, others are zero except
for the lock bit at offset `XLEN-1`.
| `XLEN` | `mlwidlist` | WARL for M | ??? | Set of WID values delegated to
M-mode, represented as a bit vector.  `NWorlds` LSBs are used,
others are zero. Register is locked (read-only) whenever `mwid` is locked.
|===

All RISC-V Worlds extensions support NWorlds {le} `XLEN`.

=== One world per hart (no ISA extension)

In this case, there are no ISA-visible additions to the RISC-V hart.  The hart
is reset into a single world and all transactions from that hart, regardless of
privilege mode, are tagged with the WID of that world. This WID is
platform-defined, we refer to it as `pmwid`, and it might take any non-ISA form
(external to the hart). E.g. pinstrap, fuse, SoC register, etc. The assignment
of WIDs to harts, and whether (and how) a hart is able to determine any
information about Worlds configuration, is platform-specific.

.One world with no ISA extension
image::drawio/world_none.svg[WorldNone,align="center"]

=== One world per hart with the Smwid extension

This extension introduces the lockable `mwid` CSR. This CSR provides a view of
the WID value for all outgoing transactions and includes a sticky lock-bit to
determine its mutability. The lock bit (`L`) is at offset `XLEN-1` within the CSR.
The WID field occupies the Ceil(Log~2~NWorlds)-1:0 writable bits.

The lock bit is sticky, meaning that once set it cannot be unset until the
hart is reset.  Once the `mwid` CSR is locked (by setting `L` to 1), any attempt
to write to the CSR is ignored. The CSR becomes read-only.

On-reset, the `mwid` CSR is expected to show the platform-defined `pmwid` value.
The `mwid` CSR may be locked immediately out of reset, or the platform may
leave it unlocked in the case that early-boot M-mode code is responsible for
setting the WID (and locking it, presumably).

The platform may limit the set of WIDs that may be used with `mwid` via a
non-ISA `pmwidlist` mask. `pmwid` must be included in `pmwidlist`.
Assigning a WID value to `mwid` that is not enabled by that  `pmwidlist` mask
will result in the hart's transactions being trapped. This will
result in a complete hang of the hart (it will be unable to fetch
instructions), but that is the appropriate outcome if M-mode attempts to
contravene platform-imposed constraints.

.One world with the Smwid extension
image::drawio/Smwid.svg[Smwid,align="center"]

=== Smlwid extension

The Smlwid extension adds support for M-mode to control the world used
by less-privileged modes, and can only be added to harts with at
least two privilege modes.

The Smlwid extension adds the `mlwid` CSR, which is an M-mode read-write
CSR, whose least-significant bits set the WID to be used by
lower-privilege modes.

NOTE: Smlwid is not dependent on Smwid extension.

NOTE: If the system supports demand-paged virtual memory, then any
address-translation caches must ensure that translations are cached
separately for each WID.  A simple implementation can flush
address-translation caches on any `mlwid` write.

The `mlwid` CSR is WARL that can contain Ceil(Log~2~NWorlds)-1:0 writable
bits.

It is platform-specific which worlds can be used by lower-privilege modes
on this hart. This may be constrained by a non-ISA `pmlwidlist` mask.
`pmlwidlist` (width of NWorlds) represents a set of WIDs as a bit vector,
with WID _i_ represented by bit _i_ of the register. Each bit indicates whether
the corresponding WID is authorized for use with `mlwid`.

NOTE: There is no HW discovery mechanism for M-mode software to discover the
available worlds and their permissions (besides taking exceptions). Information
about worlds and resources assignment must be provided to SW via sideband
channels.  The platform software will have predetermined allocations for the
worlds on a platform and all required information needed by M-mode software
must be provided out-of-band.

If an unauthorized WID is written to `mlwid`, meaning that the WID value is not
enabled in the platform's `pmlwidlist` mask, then the lower-privilege mode's
first attempt to fetch an instruction will take a precise exception.  This
exception will indicate the "software-check" cause.
Similarly, after an MPRV update in `mstatus` to
modify the effective privilege mode for loads and stores executed in M-mode
(for them to take effect as S or U mode accesses), then the first such load or
store will take a precise software-check exception if `mlwid` is not
authorized.

When this exception is raised, the `mtval` register is set to "illegal world
fault (code=4)".  The software-check exception caused by Smlwid has higher
priority than any access-fault exception (See <<exception-priority>> of
Privileged Specification) and leads to a trap being delivered to M-mode. For
example, if M-mode uses MPRV to issue a transaction as S or U mode,
that transaction may be eligible to generate an access fault (due
to MMU and/or PMP constraints) _as well as_ a software-check exception (due to
an unauthorized WID) - in that case, the software-check has priority and
supercedes the access fault.

.Smlwid extension: Support for M-mode to control lower privilege modes' world, shown here without Smwid.
image::drawio/Smlwid.svg[Smlwid_none,align="center"]

M-mode may have a different WID than any assignable by `mlwid` to
lower-privilege modes.

NOTE: The platform is not required to allow lower-privilege modes to be in the
same world as M-mode. `pmwid` may not be included in `pmlwidlist`. It is up to
the platform to determine whether or not to allow this.

=== Smlwidlist extension

The Smlwidlist extension depends on the Smwid and Smlwid extensions, it
introduces the `mlwidlist` CSR to allow M-mode to further restrict the set of
WIDs that may be used with `mlwid` (beyond any limitations already imposed by
the platform via the `pmlwidlist` mask). Like `pmlwidlist`, `mlwidlist` (width
of NWorlds) represents a set of WIDs as a bit vector, with WID _i_ represented
by bit _i_ of the register.

On-reset, the `mlwidlist` CSR is expected to show the platform-defined
`pmlwidlist` value.

The `mlwidlist` CSR is locked (read-only) whenever `mwid` is locked, it does
not have a distinct lock bit.

.Smlwidlist extension, shown here with the Smwid and Smlwid dependencies.
image::drawio/Smlwidlist.svg[Smlwidlist,align="center"]

The `mlwidlist` mask is WARL such that any attempts to enable a WID in the mask
that is not enabled in the platform's `pmlwidlist` will be overriden. I.e. a
write to `mlwidlist` followed by a read will return the result of a bitwise-AND
between the written value and the platform mask.

=== Smwdeleg / Sswid extensions

The Smwdeleg extension requires the Smlwid extension and allows M-mode to
delegate to S-mode the ability to allocate WIDs to privilege modes
lower than S.  The Smwdeleg extension optionally enables the Sswid extension
for S-mode.

NOTE: these extensions are not dependent on Smwid nor Smlwidlist.

The Smwdeleg extension adds the `mwiddeleg` M-mode read-write CSR.  The
`mwiddeleg` register represents a set of WIDs as a bit vector with
WID _i_ represented by bit _i_ of the register.  The `mwiddeleg` CSR
is a WARL register where each bit that can be set indicates a WID that
is delegated to S-mode.  The set of worlds that can be delegated to
S-mode on a hart is platform-specific.

NOTE: Different harts on a platform can have different sets of
delegable worlds.

`mwiddeleg` is always a subset of `mlwidlist` (if Smlwidlist is enabled) and
`pmlwidlist` (if implemented by the platform). Attempts to authorize a WID in
`mwiddeleg` that is not authorized in `mlwidlist`/`pmlwidlist` will fail - the
WARL behavior will mask off any such bits. Similarly, if `mlwidlist` is updated,
any WIDs that are de-authorized (set to zero) will be implicitly de-authorized
in `mwiddeleg` also.

If `mwiddeleg` is zero (which may happen even if non-zero values are written to
it, see the previous paragraph), the Sswid extension is disabled, in which case
any accesses to the `slwid` CSR raise an illegal instruction exception.
Otherwise, if `mwiddeleg` is non-zero, the Sswid extension is enabled.  Like
any other WARL register, M-mode software is expected to read back the register
to determine the actual configuration retained by the implementation.

The Sswid extension adds the S-mode read-write `slwid` CSR, which
sets the WID used for modes lower than S-mode.  The `slwid` field is WARL
that can contain Ceil(Log~2~NWorlds)-1:0 writable bits.

If an unauthorized WID (per the `mwiddeleg` list) is written to `slwid`, then
the first attempt to fetch an instruction by U-mode will take a precise
exception indicating the software-check cause.  Similarly, after a MPRV update,
any attempt by M-mode to perform a load or store "as U-mode" will be subject to
the same `mwiddeleg` authorization check, meaning that it may also take a
precise exception (indicating the software-check cause).

When this exception is raised, the `mtval` register is set to "illegal world
fault (code=4)".  The software-check exception caused by Sswid has higher
priority than any access-fault exception (See <<exception-priority>> of 
Privileged Specification) and leads to a trap being delivered to M-mode.

.Smwdeleg/Sswid extensions: Support for S-mode to control U-mode's world. Shown here without Smwid or Smlwidlist.
image::drawio/Smwdeleg_Sswid.svg[Smwdeleg_Sswid,align="center"]

NOTE: If the system supports demand-paged virtual memory, then any
address-translation caches must ensure that translations are cached
separately for each WID.  A simple implementation can flush
address-translation caches on any write to `mwiddeleg` or `slwid`.

NOTE: The Sswid extension is not available to a guest OS.

There is no requirement for `mwiddeleg` to contain the WID in `mlwid`,
i.e., S-mode can be set to a different world than the ones it is
allowed to assign to U-mode using `slwid` when Sswid is enabled.

At reset, `mwiddeleg` is set to zero and hence Sswid is disabled.

=== Response to permission violations

When a hart attempts an explicit or implicit memory access that fails
a World permissions check, the access may or may not raise an
access-fault exception of the appropriate type (i.e.,
instruction-access fault, load-access fault, or store/AMO-access
fault).  When an access-fault exception cannot be raised, the
instruction performing the memory access can be retired but any writes
to the protected physical memory location are ignored and any memory
reads return data independent of the value in the protected physical
memory location to avoid violating memory isolation.

NOTE: Secure systems will typically ensure that some agent is notified
when an illegal access is attempted, even when an access-fault
exception cannot be raised on the hart context.

NOTE: We cannot require that reads that fail permissions checks but
that do not raise access-fault exceptions return a specific value
(e.g, zero) to the hart as this is incompatible with some
cache-coherence protocols, which may require cache-resident data be
modifiable even when the underlying physical memory locations are
protected and the bus responses previously returned zero.
